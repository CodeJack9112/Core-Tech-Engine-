\
#include "../include/RendererGL.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>

// Note: this implementation assumes you have GLFW and GLAD available and linked in your build.
// It uses them at runtime. Replace with your preferred loader if needed.
#include <GLFW/glfw3.h>
#include <glad/glad.h>

RendererGL::~RendererGL(){ shutdown(); }

bool RendererGL::initialize(int width, int height, const char* title){
    m_width = width; m_height = height;
    if(!glfwInit()){
        std::cerr << "GLFW init failed" << std::endl;
        return false;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
    GLFWwindow* window = glfwCreateWindow(m_width, m_height, title, NULL, NULL);
    if(!window){ glfwTerminate(); return false; }
    glfwMakeContextCurrent(window);
    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){
        std::cerr << "Failed to initialize GLAD" << std::endl;
        return false;
    }
    glViewport(0,0,m_width,m_height);
    m_window = window;
    createDemoMesh();
    return true;
}

void RendererGL::runMainLoop(PhysicsManager* phys){
    GLFWwindow* window = (GLFWwindow*)m_window;
    while(window && !glfwWindowShouldClose(window)){
        // Poll events
        glfwPollEvents();
        // step physics
        if(phys && phys->dynamicsWorld()) phys->dynamicsWorld()->stepSimulation(1.0f/60.0f);
        if(phys) phys->processCollisionCallbacks();
        renderFrame();
        glfwSwapBuffers(window);
    }
}

void RendererGL::shutdown(){
    destroyDemoMesh();
    if(m_window){
        glfwDestroyWindow((GLFWwindow*)m_window);
        m_window = nullptr;
    }
    glfwTerminate();
}

bool RendererGL::loadAndCompile(const std::string& vsPath, const std::string& fsPath){
    std::ifstream vsf(vsPath), fsf(fsPath);
    if(!vsf || !fsf) return false;
    std::stringstream vss, fss;
    vss << vsf.rdbuf(); fss << fsf.rdbuf();
    std::string vsSrc = vss.str(), fsSrc = fss.str();
    unsigned int vs = 0, fs = 0;
    if(!compileShader(vsSrc, GL_VERTEX_SHADER, vs)) return false;
    if(!compileShader(fsSrc, GL_FRAGMENT_SHADER, fs)){ glDeleteShader(vs); return false; }
    unsigned int prog = glCreateProgram();
    glAttachShader(prog, vs); glAttachShader(prog, fs);
    glLinkProgram(prog);
    int success; glGetProgramiv(prog, GL_LINK_STATUS, &success);
    if(!success){ char info[512]; glGetProgramInfoLog(prog, 512, NULL, info); std::cerr << "Program link error: " << info << std::endl; glDeleteShader(vs); glDeleteShader(fs); glDeleteProgram(prog); return false; }
    glDeleteShader(vs); glDeleteShader(fs);
    if(m_shaderProgram) glDeleteProgram(m_shaderProgram);
    m_shaderProgram = prog;
    return true;
}

bool RendererGL::compileShader(const std::string& src, unsigned int shaderType, unsigned int &outShader){
    unsigned int shader = glCreateShader(shaderType);
    const char* cstr = src.c_str();
    glShaderSource(shader, 1, &cstr, NULL);
    glCompileShader(shader);
    int success; glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if(!success){ char info[512]; glGetShaderInfoLog(shader, 512, NULL, info); std::cerr << "Shader compile error: " << info << std::endl; glDeleteShader(shader); return false; }
    outShader = shader; return true;
}

void RendererGL::renderFrame(){
    glClearColor(0.2f,0.2f,0.25f,1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    if(m_shaderProgram){
        glUseProgram(m_shaderProgram);
        // set simple uniforms if present
        int loc = glGetUniformLocation(m_shaderProgram, "uViewPos");
        if(loc>=0) glUniform3f(loc, m_viewPos[0], m_viewPos[1], m_viewPos[2]);
        glBindVertexArray(m_vao);
        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
    }
}

void RendererGL::createDemoMesh(){
    // create cube
    float vertices[] = {
        // positions        normals         texcoords
        -1,-1,-1,  0,0,-1,  0,0,
         1,-1,-1,  0,0,-1,  1,0,
         1, 1,-1,  0,0,-1,  1,1,
        -1, 1,-1,  0,0,-1,  0,1,
        -1,-1, 1,  0,0,1,   0,0,
         1,-1, 1,  0,0,1,   1,0,
         1, 1, 1,  0,0,1,   1,1,
        -1, 1, 1,  0,0,1,   0,1,
    };
    unsigned int indices[] = {
        0,1,2, 0,2,3, 4,5,6, 4,6,7, 0,1,5, 0,5,4,
        2,3,7, 2,7,6, 0,3,7, 0,7,4, 1,2,6, 1,6,5
    };
    glGenVertexArrays(1, &m_vao);
    glGenBuffers(1, &m_vbo);
    glGenBuffers(1, &m_ebo);
    glBindVertexArray(m_vao);
    glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_ebo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
    // pos
    glEnableVertexAttribArray(0); glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)0);
    // normal
    glEnableVertexAttribArray(1); glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(3*sizeof(float)));
    // texcoord
    glEnableVertexAttribArray(2); glVertexAttribPointer(2,2,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(6*sizeof(float)));
    glBindVertexArray(0);
}

void RendererGL::destroyDemoMesh(){
    if(m_ebo) { glDeleteBuffers(1, &m_ebo); m_ebo = 0; }
    if(m_vbo) { glDeleteBuffers(1, &m_vbo); m_vbo = 0; }
    if(m_vao) { glDeleteVertexArrays(1, &m_vao); m_vao = 0; }
}

void RendererGL::setViewPos(float x, float y, float z){ m_viewPos[0]=x; m_viewPos[1]=y; m_viewPos[2]=z; }
