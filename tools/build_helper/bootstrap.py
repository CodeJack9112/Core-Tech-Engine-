#!/usr/bin/env python3
"""
Bootstrap helper for CoreTech Engine
- Detects network connectivity and presence of prebuilt libraries under `prebuilt/`
- Generates `cmake/local_toolchain.cmake` to guide CMake (sets FETCH_DEPS, USE_PREBUILT_*, PREBUILT_*_DIR)
- Optionally attempts to download prebuilt bundles if online (configurable)
Usage: python tools/build_helper/bootstrap.py [--download] [--force]
The script is safe to run multiple times. It writes cmake/local_toolchain.cmake.
"""
import os, sys, json, urllib.request, subprocess, argparse, shutil, time

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
PREBUILT_DIR = os.path.join(ROOT, "prebuilt")
LOCAL_TOOLCHAIN = os.path.join(ROOT, "cmake", "local_toolchain.cmake")

# List of third-party dependency names we support as prebuilt
DEPS = {
    "enet": {"dirs": ["enet"]},
    "lua": {"dirs": ["lua"]},
    "glfw": {"dirs": ["glfw"]},
    "glm": {"dirs": ["glm"]},
    "nlohmann_json": {"dirs": ["nlohmann_json","json"]},
    "imgui": {"dirs": ["imgui"]},
    "glad": {"dirs": ["glad"]},
    "assimp": {"dirs": ["assimp"]},
    "miniaudio": {"dirs": ["miniaudio"]},
}

def has_network(host="https://github.com", timeout=3.0):
    try:
        urllib.request.urlopen(host, timeout=timeout)
        return True
    except Exception:
        return False

def find_prebuilt(dep):
    """Return path to prebuilt dir for dep under prebuilt/ if exists, else None"""
    for d in DEPS.get(dep, {}).get("dirs", []):
        cand = os.path.join(PREBUILT_DIR, d)
        if os.path.isdir(cand):
            return os.path.abspath(cand)
    return None

def generate_toolchain(conf):
    """Write cmake/local_toolchain.cmake with sensible defaults based on conf dict"""
    lines = []
    lines.append('# Auto-generated by tools/build_helper/bootstrap.py on %s' % time.asctime())
    lines.append('# This file sets CMake cache variables to select prebuilt or FetchContent behavior')
    # Set FETCH_DEPS depending on network or user preference
    if conf.get("force_prebuilt", False):
        lines.append('set(FETCH_DEPS OFF CACHE BOOL "Auto-generated: disable fetch content (use prebuilt)")')
    else:
        lines.append('set(FETCH_DEPS %s CACHE BOOL "Auto-generated: toggle FetchContent")' % ("ON" if conf.get("network", False) and not conf.get("prefer_prebuilt", False) else "OFF"))
    # For each dep, set USE_PREBUILT_* and PREBUILT_*_DIR if found
    for dep in DEPS.keys():
        pre = conf.get("prebuilt_paths", {}).get(dep)
        var_use = 'USE_PREBUILT_%s' % dep.upper()
        var_dir = 'PREBUILT_%s_DIR' % dep.upper()
        if pre:
            lines.append('set(%s ON CACHE BOOL "Auto-generated: use prebuilt %s")' % (var_use, dep))
            # make path relative to project root for portability
            rel = os.path.relpath(pre, ROOT).replace('\\', '/')
            lines.append('set(%s "%s" CACHE PATH "Auto-generated: prebuilt %s dir")' % (var_dir, rel, dep))
        else:
            lines.append('set(%s OFF CACHE BOOL "Auto-generated: use prebuilt %s")' % (var_use, dep))
    # Emit a helpful message
    lines.append('message(STATUS "local_toolchain.cmake applied: FETCH_DEPS=%s")' % ("ON" if conf.get("network", False) and not conf.get("prefer_prebuilt", False) else "OFF"))
    # Write file
    d = os.path.dirname(LOCAL_TOOLCHAIN)
    os.makedirs(d, exist_ok=True)
    with open(LOCAL_TOOLCHAIN, "w", encoding="utf-8") as f:
        f.write("\\n".join(lines))
    print("Wrote local toolchain:", LOCAL_TOOLCHAIN)

def attempt_download_prebuilt(dep):
    """Attempt to download a prebuilt archive for dep into prebuilt/ if network is available.
    Note: This is heuristic and will not always find binaries. It is best-effort and non-fatal.
    """
    # Example: try release asset URLs for some deps (this is best-effort; may fail)
    urls = {
        "glfw": "https://github.com/glfw/glfw/releases/latest/download/glfw-3.3.8.bin.WIN32.zip",
        # Note: many projects do not ship cross-platform prebuilt zips under deterministic names.
    }
    if dep not in urls:
        return False
    url = urls[dep]
    print("Attempting to download prebuilt for", dep, "from", url)
    try:
        target_dir = os.path.join(PREBUILT_DIR, dep)
        os.makedirs(target_dir, exist_ok=True)
        local_zip = os.path.join(target_dir, "download.zip")
        with urllib.request.urlopen(url, timeout=30) as r, open(local_zip, "wb") as out:
            shutil.copyfileobj(r, out)
        # try to unpack zip (if zipfile)
        import zipfile
        with zipfile.ZipFile(local_zip, 'r') as z:
            z.extractall(target_dir)
        os.remove(local_zip)
        print("Downloaded and extracted prebuilt for", dep, "to", target_dir)
        return True
    except Exception as e:
        print("Download failed for", dep, ":", e)
        return False

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--download", action="store_true", help="Try to download prebuilt bundles (best-effort)")
    parser.add_argument("--force-prebuilt", action="store_true", help="Force use of prebuilt and disable fetch even if network available")
    parser.add_argument("--prefer-prebuilt", action="store_true", help="Prefer prebuilt over fetching when both available")
    args = parser.parse_args()

    conf = {"network": False, "prebuilt_paths": {}, "force_prebuilt": args.force_prebuilt, "prefer_prebuilt": args.prefer_prebuilt}

    net = has_network()
    conf["network"] = net
    print("Network available?" , net)

    # find prebuilt dirs
    for dep in DEPS.keys():
        p = find_prebuilt(dep)
        if p:
            conf["prebuilt_paths"][dep] = p

    # If download requested and network available, attempt to download missing prebuilt deps
    if args.download and net:
        for dep in DEPS.keys():
            if dep not in conf["prebuilt_paths"]:
                ok = attempt_download_prebuilt(dep)
                if ok:
                    conf["prebuilt_paths"][dep] = find_prebuilt(dep)

    # If no prebuilt found and no network, create minimal stubs to allow configure
    if not net and not conf["prebuilt_paths"]:
        # create minimal prebuilt structure with stub headers/libs for critical deps
        os.makedirs(PREBUILT_DIR, exist_ok=True)
        for dep in ["miniaudio","enet","lua"]:
            d = os.path.join(PREBUILT_DIR, dep)
            os.makedirs(os.path.join(d, "include"), exist_ok=True)
            os.makedirs(os.path.join(d, "lib"), exist_ok=True)
            # create placeholder header to satisfy includes
            hdr = os.path.join(d, "include", dep + "_stub.h")
            if not os.path.exists(hdr):
                with open(hdr, "w", encoding="utf-8") as f:
                    f.write("// stub for %s\\n" % dep)
            conf["prebuilt_paths"][dep] = d
        print("Created minimal prebuilt stubs to allow offline configure in", PREBUILT_DIR)

    generate_toolchain(conf)
    # Print summary
    print("Bootstrap summary: network=%s, prebuilt=%s" % (conf["network"], list(conf["prebuilt_paths"].keys())))
    return 0

if __name__ == "__main__":
    sys.exit(main())
